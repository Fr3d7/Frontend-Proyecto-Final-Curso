pipeline {
  agent any

  options {
    skipDefaultCheckout(true)
    ansiColor('xterm')
    timestamps()
  }

  parameters {
    choice(name: 'TARGET_BRANCH', choices: ['DEV', 'QA', 'PROD'], description: 'Solo para jobs NO multibranch.')
  }

  environment {
    // Detecta rama: Multibranch (BRANCH_NAME) > parámetro > heurística por nombre de job > QA
    RAW_BRANCH  = "${env.BRANCH_NAME ?: (params.TARGET_BRANCH ?: (env.JOB_BASE_NAME?.toLowerCase()?.contains('prod') ? 'PROD' : (env.JOB_BASE_NAME?.toLowerCase()?.contains('qa') ? 'QA' : 'QA')))}"
    PIPE_BRANCH = "${RAW_BRANCH.toUpperCase()}"
    PROJECT_KEY = "frontend-proyecto-final-${PIPE_BRANCH}"

    // Tool SonarScanner configurado en Jenkins (Global Tool Configuration)
    SCANNER_HOME = tool 'sonar-scanner-win'

    REPO_URL = "https://github.com/Fr3d7/Frontend-Proyecto-Final-Curso.git"
    APP_DIR  = "login-registration"
  }

  stages {
    stage('Init') {
      steps {
        script {
          echo "Project: ${env.PROJECT_KEY} | Branch: ${env.PIPE_BRANCH}"
        }
      }
    }

    stage('Checkout') {
      steps {
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${PIPE_BRANCH}"]],
          userRemoteConfigs: [[url: "${env.REPO_URL}", credentialsId: 'github-creds']]
        ])
        bat 'if not exist "%APP_DIR%" (echo ERROR: falta %APP_DIR%  & dir /b & exit /b 1)'
      }
    }

    stage('Install deps') {
      steps {
        dir("${APP_DIR}") {
          bat 'chcp 65001 >NUL & npm ci || npm install'
        }
      }
    }

    stage('Seed minimal test if missing') {
      steps {
        dir("${APP_DIR}") {
          // TODO: Todo el JS en UNA sola línea para que cmd.exe no se lo coma
          bat '''
            chcp 65001 >NUL
            node -e "const fs=require('fs');fs.mkdirSync('src/__tests__',{recursive:true});fs.mkdirSync('src/utils',{recursive:true});if(!fs.existsSync('src/utils/sum.js')){fs.writeFileSync('src/utils/sum.js','export function sum(a,b){return a+b;}');}if(!fs.existsSync('src/__tests__/smoke.test.js')){fs.writeFileSync('src/__tests__/smoke.test.js','import {sum} from \\'../utils/sum\\';test(\\'sum 2+3=5\\',()=>{expect(sum(2,3)).toBe(5);});');}console.log('Smoke test listo');"
          '''
        }
      }
    }

    stage('Run tests (coverage)') {
      steps {
        dir("${APP_DIR}") {
          // Usa tu script test:ci si existe; si no, ejecuta react-scripts directo
          bat '''
            chcp 65001 >NUL
            (npm run test:ci) || (npx react-scripts test --ci --watchAll=false --runInBand --coverage --coverageReporters=lcov,text-summary --coverageDirectory=coverage --collectCoverageFrom=src/**/*.{js,jsx,ts,tsx})
            if not exist coverage\\lcov.info (echo ERROR: NO existe coverage\\lcov.info & exit /b 1)
            for %%I in (coverage\\lcov.info) do (
              echo LCOV bytes: %%~zI
              if "%%~zI"=="0" (echo ERROR: LCOV vacio & exit /b 1)
            )
          '''
        }
      }
    }

    stage('Build app') {
      steps {
        dir("${APP_DIR}") {
          // Evita que CRA trate warnings como errores
          withEnv(['CI=false']) {
            bat 'chcp 65001 >NUL & npm run build'
          }
        }
      }
    }

    stage('SonarQube Analysis') {
      steps {
        dir("${APP_DIR}") {
          withCredentials([string(credentialsId: 'sonarqube-token', variable: 'SONAR_TOKEN')]) {
            withSonarQubeEnv('sonar-local') {
              bat '''
                chcp 65001 >NUL
                if not exist coverage\\lcov.info (echo ERROR: NO existe coverage\\lcov.info antes de sonar & exit /b 1)
                for %%I in (coverage\\lcov.info) do (
                  echo LCOV previo a sonar: %%~zI bytes
                  if "%%~zI"=="0" (echo ERROR: LCOV vacio antes de sonar & exit /b 1)
                )
                "%SCANNER_HOME%\\bin\\sonar-scanner.bat" ^
                  -Dsonar.projectKey=${PROJECT_KEY} ^
                  -Dsonar.projectName=${PROJECT_KEY} ^
                  -Dsonar.projectVersion=%BUILD_NUMBER% ^
                  -Dsonar.projectBaseDir=%CD% ^
                  -Dsonar.sources=src ^
                  -Dsonar.exclusions=node_modules/**,build/**,coverage/** ^
                  -Dsonar.tests=src ^
                  -Dsonar.test.inclusions=**/*.test.*,**/*.spec.*,src/__tests__/**/* ^
                  -Dsonar.coverage.exclusions=**/*.test.*,**/*.spec.*,src/__tests__/**/*,node_modules/**,build/**,coverage/** ^
                  -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info ^
                  -Dsonar.scm.exclusions.disabled=true ^
                  -Dsonar.sourceEncoding=UTF-8 ^
                  -Dsonar.token=%SONAR_TOKEN%
              '''
            }
          }
        }
      }
    }

    stage('Quality Gate') {
      steps {
        timeout(time: 10, unit: 'MINUTES') {
          waitForQualityGate abortPipeline: true
        }
      }
    }

    stage('Package artifact') {
      steps {
        archiveArtifacts artifacts: "${APP_DIR}/build/**", fingerprint: true
        archiveArtifacts artifacts: "${APP_DIR}/coverage/**", allowEmptyArchive: true
      }
    }

    stage('Deploy') {
      when {
        expression { return env.PIPE_BRANCH == 'QA' || env.PIPE_BRANCH == 'PROD' }
      }
      steps {
        script {
          def deployPath = (env.PIPE_BRANCH == 'PROD') ? 'C:\\deploy\\frontend' : 'C:\\deploy\\frontend-qa'
          bat "if not exist \"${deployPath}\" mkdir \"${deployPath}\""
          bat "xcopy /E /I /Y \"${env.WORKSPACE}\\${APP_DIR}\\build\\*\" \"${deployPath}\\\""
          echo "Desplegado a ${deployPath} para rama ${env.PIPE_BRANCH}"
        }
      }
    }
  }

  post {
    always {
      echo "Fin | Rama: ${env.PIPE_BRANCH} | Build: #${env.BUILD_NUMBER}"
    }
  }
}
