pipeline {
  agent any
  options { skipDefaultCheckout(true); ansiColor('xterm'); timestamps() }

  parameters {
    choice(name: 'TARGET_BRANCH', choices: ['DEV','QA','PROD'], description: 'Solo para jobs NO multibranch.')
  }

  environment {
    RAW_BRANCH  = "${env.BRANCH_NAME ?: (params.TARGET_BRANCH ?: (env.JOB_BASE_NAME?.toLowerCase()?.contains('prod') ? 'PROD' : (env.JOB_BASE_NAME?.toLowerCase()?.contains('qa') ? 'QA' : 'DEV')))}"
    PIPE_BRANCH = "${RAW_BRANCH.toUpperCase()}"
    PROJECT_KEY = "frontend-proyecto-final-${PIPE_BRANCH}"
    SCANNER_HOME = tool 'sonar-scanner-win'
    REPO_URL = "https://github.com/Fr3d7/Frontend-Proyecto-Final-Curso.git"
  }

  stages {
    stage('Checkout') {
      steps {
        echo "üì¶ Proyecto: ${env.PROJECT_KEY} | üßµ Rama destino: ${env.PIPE_BRANCH}"
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${PIPE_BRANCH}"]],
          userRemoteConfigs: [[url: "${env.REPO_URL}", credentialsId: 'github-creds']]
        ])
      }
    }

    stage('Install dependencies') {
      steps {
        bat 'npm ci || npm install'
        bat 'npm ls @testing-library/react || npm i -D @testing-library/react @testing-library/jest-dom'
      }
    }

    stage('Clean conflicting Jest/Babel configs') {
      steps {
        bat 'if exist jest.config.cjs del /f /q jest.config.cjs'
        bat 'if exist jest.config.js  del /f /q jest.config.js'
        bat 'if exist babel.config.cjs del /f /q babel.config.cjs'
        bat 'if exist babel.config.js  del /f /q babel.config.js'
      }
    }

    stage('Ensure smoke test') {
      steps {
        bat 'if not exist src\\__tests__\\ mkdir src\\__tests__'
        writeFile file: 'src/__tests__/ci.smoke.test.jsx', text: '''
import "@testing-library/jest-dom";
test("smoke in __tests__", () => { expect(1+1).toBe(2); });
'''.stripIndent()
        // segunda ubicaci√≥n para garantizar descubrimiento en CRA
        writeFile file: 'src/ci.smoke.test.js', text: '''
test("smoke in root", () => { expect(true).toBe(true); });
'''.stripIndent()
      }
    }

    stage('Run tests (coverage via CRA)') {
      steps {
        bat '''
          set CI=true
          npm test -- --coverage --watchAll=false --passWithNoTests ^
            --collectCoverageFrom="src/**/*.{js,jsx,ts,tsx}" ^
            --collectCoverageFrom="!src/**/__tests__/**"
        '''
        // normaliza rutas del LCOV con PowerShell (sin peleas de escapes)
        writeFile file: 'scripts/fix-lcov.ps1', text: '''
$path = "coverage/lcov.info"
if (Test-Path $path) {
  $c = Get-Content -Raw $path
  $c = $c -replace "\\\\","/"
  Set-Content -NoNewline -Path $path -Value $c
}
'''.stripIndent()
        bat 'if exist coverage\\lcov.info powershell -NoProfile -ExecutionPolicy Bypass -File scripts\\fix-lcov.ps1'
        // imprime tama√±o de LCOV sin romper el build
        bat 'powershell -NoProfile -Command "if (Test-Path ''coverage/lcov.info'') { $s=(Get-Item ''coverage/lcov.info'').Length; Write-Output (''LCOV size='' + $s + '' bytes'') } else { Write-Output ''WARN: no coverage/lcov.info'' }"'
      }
    }

    stage('Build app') {
      steps {
        bat '''
          set CI=
          npm run build
        '''
      }
    }

    stage('SonarQube Analysis') {
      steps {
        withCredentials([string(credentialsId: 'sonarqube-token', variable: 'SONAR_TOKEN')]) {
          withSonarQubeEnv('sonar-local') {
            bat """
              "${SCANNER_HOME}\\bin\\sonar-scanner.bat" ^
                -Dsonar.projectKey=${PROJECT_KEY} ^
                -Dsonar.projectName=${PROJECT_KEY} ^
                -Dsonar.projectVersion=${BUILD_NUMBER} ^
                -Dsonar.projectBaseDir=%WORKSPACE% ^
                -Dsonar.sources=src ^
                -Dsonar.tests=src ^
                -Dsonar.test.inclusions=**/*.test.js,**/*.test.jsx,**/*.test.ts,**/*.test.tsx,**/*.spec.js,**/*.spec.jsx,**/*.spec.ts,**/*.spec.tsx,src/**/__tests__/**/* ^
                -Dsonar.sourceEncoding=UTF-8 ^
                -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info ^
                -Dsonar.token=%SONAR_TOKEN%
            """
          }
        }
      }
    }

    stage('Quality Gate') {
      steps { timeout(time: 10, unit: 'MINUTES') { waitForQualityGate abortPipeline: true } }
    }

    stage('Package artifact') {
      steps { archiveArtifacts artifacts: 'build/**', fingerprint: true }
    }

    stage('Deploy') {
      when { expression { env.PIPE_BRANCH == 'QA' || env.PIPE_BRANCH == 'PROD' } }
      steps {
        script {
          def deployPath = (env.PIPE_BRANCH == 'PROD') ? 'C:\\deploy\\frontend' : 'C:\\deploy\\frontend-qa'
          bat """
            if not exist ${deployPath} mkdir ${deployPath}
            xcopy /E /I /Y build ${deployPath}
          """
          echo "üöÄ Desplegado a ${deployPath} para rama ${env.PIPE_BRANCH}"
        }
      }
    }
  }

  post { always { echo "üèÅ Fin | Rama: ${env.PIPE_BRANCH} | Build: #${env.BUILD_NUMBER}" } }
}
