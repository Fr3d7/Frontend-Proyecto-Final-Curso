pipeline {
  agent any
  options {
    skipDefaultCheckout(true)          // Evita doble checkout
    ansiColor('xterm')
    timestamps()
  }

  parameters {
    choice(name: 'TARGET_BRANCH', choices: ['DEV', 'QA', 'PROD'], description: 'Solo para jobs NO multibranch. Ignorado si BRANCH_NAME existe.')
  }

  environment {
    // Detecta rama: 1) Multibranch (BRANCH_NAME), 2) par√°metro, 3) por nombre del job
    RAW_BRANCH   = "${env.BRANCH_NAME ?: (params.TARGET_BRANCH ?: (env.JOB_BASE_NAME?.toLowerCase()?.contains('prod') ? 'PROD' : (env.JOB_BASE_NAME?.toLowerCase()?.contains('qa') ? 'QA' : 'DEV')))}"
    PIPE_BRANCH  = "${RAW_BRANCH.toUpperCase()}"
    PROJECT_KEY  = "frontend-proyecto-final-${PIPE_BRANCH}"
    // Ajusta esta ruta si tu instalaci√≥n del scanner es distinta
    SCANNER_BAT  = "C:\\ProgramData\\Jenkins\\.jenkins\\tools\\hudson.plugins.sonar.SonarRunnerInstallation\\sonar-scanner-win\\bin\\sonar-scanner.bat"
    REPO_URL     = "https://github.com/Fr3d7/Frontend-Proyecto-Final-Curso.git"
  }

  stages {
    stage('Checkout') {
      steps {
        script {
          echo "üì¶ Proyecto: ${env.PROJECT_KEY} | üßµ Rama destino: ${env.PIPE_BRANCH}"
        }
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${PIPE_BRANCH}"]],
          doGenerateSubmoduleConfigurations: false,
          extensions: [],
          submoduleCfg: [],
          userRemoteConfigs: [[url: "${env.REPO_URL}", credentialsId: 'github-creds']]
        ])
      }
    }

    stage('Install dependencies') {
      steps {
        bat 'npm ci || npm install'
      }
    }

    stage('Run tests (coverage)') {
      steps {
        // Si no hay tests, no falla y a√∫n as√≠ genera lcov si existiera
        bat 'npm test -- --coverage --watchAll=false --ci --passWithNoTests'
      }
    }

    stage('Build app') {
      steps {
        bat '''
          set CI=
          npm run build
        '''
      }
    }

    stage('SonarQube Analysis') {
      steps {
        withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
          withSonarQubeEnv('sonar-local') {
            // Aviso si no existe coverage/lcov.info (no falla)
            bat 'if not exist coverage\\lcov.info (echo "WARN: no coverage\\lcov.info")'
            bat """
              "${SCANNER_BAT}" ^
                -Dsonar.projectKey=${PROJECT_KEY} ^
                -Dsonar.projectName=${PROJECT_KEY} ^
                -Dsonar.projectVersion=${BUILD_NUMBER} ^
                -Dsonar.projectBaseDir=%WORKSPACE% ^
                -Dsonar.sources=src ^
                -Dsonar.tests=src ^
                -Dsonar.test.inclusions=**/*.test.js,**/*.spec.js ^
                -Dsonar.sourceEncoding=UTF-8 ^
                -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info ^
                -Dsonar.token=%SONAR_TOKEN%
            """
          }
        }
      }
    }

    stage('Quality Gate') {
      steps {
        timeout(time: 10, unit: 'MINUTES') {
          // Aborta el pipeline si el Gate falla
          waitForQualityGate abortPipeline: true
        }
      }
    }

    stage('Package artifact') {
      steps {
        archiveArtifacts artifacts: 'build/**', fingerprint: true
      }
    }

    stage('Deploy') {
      when {
        expression { return env.PIPE_BRANCH == 'QA' || env.PIPE_BRANCH == 'PROD' }
      }
      steps {
        script {
          def deployPath = (env.PIPE_BRANCH == 'PROD') ? 'C:\\deploy\\frontend' : 'C:\\deploy\\frontend-qa'
          bat """
            if not exist ${deployPath} mkdir ${deployPath}
            xcopy /E /I /Y build ${deployPath}
          """
          echo "üöÄ Desplegado a ${deployPath} para rama ${env.PIPE_BRANCH}"
        }
      }
    }
  }

  post {
    always {
      echo "üèÅ Fin | Rama: ${env.PIPE_BRANCH} | Build: #${env.BUILD_NUMBER}"
    }
  }
}
